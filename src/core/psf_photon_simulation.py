import os
import sys
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.colors import LinearSegmentedColormap
import pandas as pd
from scipy.stats import poisson
import argparse
from pathlib import Path

# Import functions from your existing psf_plot.py
# This assumes the script is in the same directory as psf_plot.py
script_dir = os.path.dirname(os.path.abspath(__file__))
sys.path.append(script_dir)

# Import parse_psf_file and other relevant functions from your psf_plot.py
from .psf_plot import parse_psf_file, analyze_psf

def load_radiometry_data(csv_file_path):
    """
    Load radiometry data from CSV files generated by your coworker.
    
    Args:
        csv_file_path (str): Path to the CSV file
        
    Returns:
        pandas.DataFrame: DataFrame containing the radiometry data
    """
    try:
        # Try to load the CSV file
        df = pd.read_csv(csv_file_path)
        print(f"Successfully loaded radiometry data from {csv_file_path}")
        return df
    except Exception as e:
        print(f"Error loading radiometry data: {str(e)}")
        return None

def normalize_psf(intensity_data):
    """
    Normalize the PSF so the sum equals 1.0 (probability distribution)
    
    Args:
        intensity_data (np.ndarray): 2D array of intensity values
        
    Returns:
        np.ndarray: Normalized PSF
    """
    # Check if intensity_data has any non-zero values
    if np.sum(intensity_data) > 0:
        return intensity_data / np.sum(intensity_data)
    else:
        print("Warning: PSF contains only zeros or is empty!")
        return intensity_data

def simulate_photon_distribution(psf_data, num_photons, num_simulations=1):
    """
    Simulate where individual photons land based on PSF probability distribution
    
    Args:
        psf_data (np.ndarray): 2D array containing the PSF intensity values
        num_photons (int): Number of photons to simulate
        num_simulations (int): Number of Monte Carlo simulations to run
        
    Returns:
        dict: Dictionary containing simulation results:
            - 'mean_image': Average image across all simulations
            - 'simulations': List of all simulated images if num_simulations > 1
            - 'std_image': Standard deviation image across simulations
    """
    # Normalize PSF to create probability distribution
    psf_normalized = normalize_psf(psf_data)
    
    # Create flattened probability distribution for sampling
    prob_flat = psf_normalized.flatten()
    
    # Check for invalid values in probability distribution
    if np.any(np.isnan(prob_flat)) or np.any(np.isinf(prob_flat)):
        print("Warning: PSF contains NaN or Inf values!")
        # Replace NaNs and Infs with zeros
        prob_flat = np.nan_to_num(prob_flat, nan=0.0, posinf=0.0, neginf=0.0)
    
    # Renormalize after fixing any invalid values
    if np.sum(prob_flat) > 0:
        prob_flat = prob_flat / np.sum(prob_flat)
    
    # Store all simulation results
    simulated_images = []
    
    for sim in range(num_simulations):
        if sim % 10 == 0 and num_simulations > 10:
            print(f"Running simulation {sim+1}/{num_simulations}")
            
        # Initialize photon count image
        photon_counts = np.zeros_like(psf_data)
        
        if num_photons > 0:
            try:
                # Generate random indices based on PSF probability
                random_indices = np.random.choice(
                    range(len(prob_flat)), 
                    size=num_photons, 
                    p=prob_flat
                )
                
                # Create the photon count image
                for idx in random_indices:
                    # Convert 1D index back to 2D coordinates
                    y, x = np.unravel_index(idx, psf_data.shape)
                    photon_counts[y, x] += 1
                    
            except Exception as e:
                print(f"Error in photon simulation: {str(e)}")
                # Fallback method if the above fails
                print("Using fallback method for photon simulation")
                for _ in range(num_photons):
                    # Generate random index based on PSF probability
                    idx = np.random.choice(range(len(prob_flat)), p=prob_flat)
                    y, x = np.unravel_index(idx, psf_data.shape)
                    photon_counts[y, x] += 1
        
        simulated_images.append(photon_counts)
    
    # Calculate mean and standard deviation across simulations
    mean_image = np.mean(simulated_images, axis=0)
    std_image = np.std(simulated_images, axis=0) if num_simulations > 1 else np.zeros_like(mean_image)
    
    return {
        'mean_image': mean_image,
        'simulations': simulated_images,
        'std_image': std_image
    }

def simulate_psf_with_poisson_noise(psf_data, num_photons, num_simulations=1):
    """
    Different approach: Instead of simulating individual photons,
    apply Poisson noise to PSF-scaled photon counts
    
    Args:
        psf_data (np.ndarray): 2D array containing the PSF intensity values
        num_photons (int): Total number of photons
        num_simulations (int): Number of Monte Carlo simulations to run
        
    Returns:
        dict: Dictionary containing simulation results
    """
    # Normalize PSF
    psf_normalized = normalize_psf(psf_data)
    
    # Expected photon counts in each pixel
    expected_counts = psf_normalized * num_photons
    
    # Store all simulation results
    simulated_images = []
    
    for sim in range(num_simulations):
        if sim % 10 == 0 and num_simulations > 10:
            print(f"Running Poisson simulation {sim+1}/{num_simulations}")
            
        # Apply Poisson noise to each pixel
        poisson_image = np.random.poisson(expected_counts)
        simulated_images.append(poisson_image)
    
    # Calculate mean and standard deviation across simulations
    mean_image = np.mean(simulated_images, axis=0)
    std_image = np.std(simulated_images, axis=0) if num_simulations > 1 else np.zeros_like(mean_image)
    
    return {
        'mean_image': mean_image,
        'simulations': simulated_images,
        'std_image': std_image
    }

def visualize_photon_simulation(original_psf, simulation_results, metadata=None, log_scale=False, save_path=None, num_photons=None, num_simulations=None):
    """
    Visualize the results of photon distribution simulation
    
    Args:
        original_psf (np.ndarray): Original PSF data
        simulation_results (dict): Results from simulate_photon_distribution
        metadata (dict, optional): Metadata dictionary
        log_scale (bool): Use logarithmic color scale
        save_path (str, optional): Path to save the figure
        num_photons (int, optional): Number of photons used in the simulation
        num_simulations (int, optional): Number of Monte Carlo simulations run
        
    Returns:
        matplotlib.figure.Figure: The figure object
    """
    # Create figure with subplots
    fig, axes = plt.subplots(1, 3, figsize=(16, 6))
    
    # Get data spacing for proper scaling
    data_spacing = metadata.get('data_spacing', 1.0) if metadata else 1.0
    ny, nx = original_psf.shape
    extent = [-nx/2 * data_spacing, nx/2 * data_spacing, 
              -ny/2 * data_spacing, ny/2 * data_spacing]
    
    # Plot original PSF
    if log_scale:
        # Add small value to avoid log(0)
        vmin = np.min(original_psf[original_psf > 0]) / 10 if np.any(original_psf > 0) else 1e-10
        im0 = axes[0].imshow(original_psf, extent=extent, origin='lower', 
                           cmap='viridis', norm=plt.cm.colors.LogNorm(vmin=vmin))
        plt.colorbar(im0, ax=axes[0], label='Log Intensity (relative)')
    else:
        im0 = axes[0].imshow(original_psf, extent=extent, origin='lower', cmap='viridis')
        plt.colorbar(im0, ax=axes[0], label='Intensity (relative)')
    
    axes[0].set_title('Original PSF')
    axes[0].set_xlabel('X Position (µm)')
    axes[0].set_ylabel('Y Position (µm)')
    
    # Plot mean simulated image
    mean_image = simulation_results['mean_image']
    im1 = axes[1].imshow(mean_image, extent=extent, origin='lower', cmap='viridis')
    plt.colorbar(im1, ax=axes[1], label='Photon Count')
    
    axes[1].set_title('Mean Simulated Photon Distribution')
    axes[1].set_xlabel('X Position (µm)')
    axes[1].set_ylabel('Y Position (µm)')
    
    # Plot standard deviation or a single simulation sample
    if len(simulation_results['simulations']) > 1:
        std_image = simulation_results['std_image']
        im2 = axes[2].imshow(std_image, extent=extent, origin='lower', cmap='plasma')
        plt.colorbar(im2, ax=axes[2], label='Std. Dev. of Photon Count')
        axes[2].set_title('Standard Deviation Across Simulations')
    else:
        # Plot the single simulation
        sim_image = simulation_results['simulations'][0]
        im2 = axes[2].imshow(sim_image, extent=extent, origin='lower', cmap='viridis')
        plt.colorbar(im2, ax=axes[2], label='Photon Count')
        axes[2].set_title('Single Simulated Photon Distribution')
    
    axes[2].set_xlabel('X Position (µm)')
    axes[2].set_ylabel('Y Position (µm)')
    
    # Add metadata as title if available
    if metadata:
        field_angle = metadata.get('field_angle', 'N/A')
        wavelength = metadata.get('wavelength_range', 'N/A')
        strehl = metadata.get('strehl_ratio', 'N/A')
        
        # Add number of photons and simulations to the title
        title = f"PSF Photon Simulation | Field Angle: {field_angle}° | Wavelength: {wavelength} | Strehl: {strehl}"
        if num_photons is not None:
            title += f" | Photons: {num_photons}"
        if num_simulations is not None:
            title += f" | Simulations: {num_simulations}"
        
        fig.suptitle(title, fontsize=14)
    
    plt.tight_layout()
    
    # Save if requested
    if save_path:
        try:
            plt.savefig(save_path, dpi=300, bbox_inches='tight')
            print(f"Figure saved to {save_path}")
        except Exception as e:
            print(f"Error saving figure: {str(e)}")
    
    return fig
def visualize_multiple_simulations(simulation_results, metadata=None, num_samples=4, save_path=None, num_photons=None, num_simulations=None):
    """
    Visualize multiple individual simulation samples
    
    Args:
        simulation_results (dict): Results from simulate_photon_distribution
        metadata (dict, optional): Metadata dictionary
        num_samples (int): Number of samples to display
        save_path (str, optional): Path to save the figure
        num_photons (int, optional): Number of photons used in the simulation
        num_simulations (int, optional): Number of Monte Carlo simulations run
        
    Returns:
        matplotlib.figure.Figure: The figure object
    """
    simulations = simulation_results['simulations']
    
    # Limit to available simulations
    num_samples = min(num_samples, len(simulations))
    
    # Calculate grid size
    grid_size = int(np.ceil(np.sqrt(num_samples)))
    
    # Create figure
    fig, axes = plt.subplots(grid_size, grid_size, figsize=(12, 12))
    axes = axes.flatten()
    
    # Get data spacing for proper scaling
    data_spacing = metadata.get('data_spacing', 1.0) if metadata else 1.0
    
    # Get dimensions from the first simulation
    ny, nx = simulations[0].shape
    extent = [-nx/2 * data_spacing, nx/2 * data_spacing, 
              -ny/2 * data_spacing, ny/2 * data_spacing]
    
    # Create a colormap that shows individual photons distinctly
    max_count = max(np.max(sim) for sim in simulations[:num_samples])
    
    # Plot individual simulations
    for i in range(num_samples):
        im = axes[i].imshow(simulations[i], extent=extent, origin='lower', 
                          cmap='viridis', vmin=0, vmax=max_count)
        axes[i].set_title(f'Simulation {i+1}')
        axes[i].set_xlabel('X Position (µm)')
        axes[i].set_ylabel('Y Position (µm)')
    
    # Hide unused subplots
    for i in range(num_samples, len(axes)):
        axes[i].axis('off')
    
    # Add colorbar
    cbar_ax = fig.add_axes([0.92, 0.15, 0.02, 0.7])
    fig.colorbar(im, cax=cbar_ax, label='Photon Count')
    
    # Add metadata as title if available
    if metadata:
        field_angle = metadata.get('field_angle', 'N/A')
        wavelength = metadata.get('wavelength_range', 'N/A')
        
        # Add number of photons and simulations to the title
        title = f"Monte Carlo Simulations of PSF Photon Distribution\nField Angle: {field_angle}° | Wavelength: {wavelength}"
        if num_photons is not None:
            title += f" | Photons: {num_photons}"
        if num_simulations is not None:
            title += f" | Simulations: {num_simulations}"
        
        fig.suptitle(title, fontsize=14)
    else:
        fig.suptitle("Monte Carlo Simulations of PSF Photon Distribution", fontsize=14)
    
    plt.tight_layout(rect=[0, 0, 0.9, 0.95])
    
    # Save if requested
    if save_path:
        try:
            plt.savefig(save_path, dpi=300, bbox_inches='tight')
            print(f"Multiple simulations figure saved to {save_path}")
        except Exception as e:
            print(f"Error saving figure: {str(e)}")
    
    return fig

def process_psf_with_radiometry(psf_filepath, num_photons, num_simulations=100, 
                              output_dir=None, show_plots=True, save_plots=True,
                              simulation_method='poisson', debug=False):
    """
    Process a PSF file with radiometry data to simulate photon distribution
    
    Args:
        psf_filepath (str): Path to the PSF file
        num_photons (int): Number of photons to simulate
        num_simulations (int): Number of Monte Carlo simulations to run
        output_dir (str, optional): Directory to save output files
        show_plots (bool): Whether to display plots
        save_plots (bool): Whether to save plots
        simulation_method (str): 'poisson' or 'monte_carlo'
        debug (bool): Whether to print debug information
        
    Returns:
        dict: Dictionary containing simulation results
    """
    print(f"Processing PSF file: {psf_filepath} with {num_photons} photons")
    
    # Parse PSF file
    metadata, intensity_data = parse_psf_file(psf_filepath, debug=debug)
    
    if intensity_data.size == 0:
        print(f"Failed to extract valid intensity data from {psf_filepath}")
        return None
    
    # Determine output directory
    if output_dir is None:
        output_dir = os.path.dirname(psf_filepath)
    
    # Create output directory if it doesn't exist
    if save_plots and output_dir and not os.path.exists(output_dir):
        os.makedirs(output_dir)
    
    # Create base filename for outputs
    filename = os.path.basename(psf_filepath)
    base, _ = os.path.splitext(filename)
    
    # Run photon distribution simulation
    if simulation_method.lower() == 'poisson':
        print(f"Running Poisson simulation with {num_photons} photons ({num_simulations} simulations)...")
        simulation_results = simulate_psf_with_poisson_noise(
            intensity_data, num_photons, num_simulations=num_simulations
        )
    else:
        print(f"Running Monte Carlo simulation with {num_photons} photons ({num_simulations} simulations)...")
        simulation_results = simulate_photon_distribution(
            intensity_data, num_photons, num_simulations=num_simulations
        )
    
    # Visualize results
    fig1 = visualize_photon_simulation(
        intensity_data, simulation_results, metadata=metadata,
        save_path=os.path.join(output_dir, f"{base}_photon_sim.png") if save_plots else None,
        num_photons=num_photons, num_simulations=num_simulations
    )
    
    if show_plots:
        plt.figure(fig1.number)
        plt.show()
    else:
        plt.close(fig1)
    
    # If we have multiple simulations, visualize a subset of them
    if num_simulations > 1:
        fig2 = visualize_multiple_simulations(
            simulation_results, metadata=metadata, num_samples=4,
            save_path=os.path.join(output_dir, f"{base}_photon_sim_samples.png") if save_plots else None,
            num_photons=num_photons, num_simulations=num_simulations
        )
        
        if show_plots:
            plt.figure(fig2.number)
            plt.show()
        else:
            plt.close(fig2)
    
    # Calculate some statistics about the photon distribution
    total_photons = np.sum(simulation_results['mean_image'])
    max_photons = np.max(simulation_results['mean_image'])
    center_of_mass = np.array(
        [np.sum(np.arange(intensity_data.shape[0]) * np.sum(simulation_results['mean_image'], axis=1)),
         np.sum(np.arange(intensity_data.shape[1]) * np.sum(simulation_results['mean_image'], axis=0))]
    ) / total_photons if total_photons > 0 else np.array([0, 0])
    
    # Print summary
    print(f"\nSimulation Summary:")
    print(f"  Input Photons: {num_photons}")
    print(f"  Actual Simulated Photons: {total_photons:.2f}")
    print(f"  Max Photons in a Pixel: {max_photons:.2f}")
    print(f"  Center of Mass: ({center_of_mass[0]:.2f}, {center_of_mass[1]:.2f}) pixels")
    
    if 'std_image' in simulation_results and np.sum(simulation_results['std_image']) > 0:
        snr = simulation_results['mean_image'] / (simulation_results['std_image'] + 1e-10)
        max_snr = np.max(snr[np.isfinite(snr)])
        print(f"  Max SNR: {max_snr:.2f}")
    
    return {
        'metadata': metadata,
        'original_psf': intensity_data,
        'simulation_results': simulation_results
    }

def batch_process_psfs_with_radiometry(directory, pattern, photon_data, 
                                     num_simulations=100, output_dir=None,
                                     show_plots=False, save_plots=True,
                                     simulation_method='poisson', debug=False):
    """
    Process multiple PSF files with radiometry data
    
    Args:
        directory (str): Directory containing PSF files
        pattern (str): Glob pattern to match PSF files
        photon_data (dict): Dictionary mapping field angles to photon counts
        num_simulations (int): Number of Monte Carlo simulations to run
        output_dir (str): Directory to save output files
        show_plots (bool): Whether to display plots
        save_plots (bool): Whether to save plots
        simulation_method (str): 'poisson' or 'monte_carlo'
        debug (bool): Whether to print debug information
        
    Returns:
        dict: Dictionary mapping filenames to simulation results
    """
    import glob
    
    # Find all matching files
    search_pattern = os.path.join(directory, pattern)
    files = glob.glob(search_pattern)
    
    if not files:
        print(f"No files found matching pattern '{pattern}' in {directory}")
        return {}
    
    print(f"Found {len(files)} files to process")
    
    # Process each file
    results = {}
    for file_path in files:
        # Extract field angle from filename or metadata
        metadata, _ = parse_psf_file(file_path, debug=debug)
        field_angle = metadata.get('field_angle', None)
        
        if field_angle is None:
            # Try to extract from filename
            import re
            filename = os.path.basename(file_path)
            match = re.search(r'(\d+(?:\.\d+)?)deg', filename)
            if match:
                field_angle = float(match.group(1))
                print(f"Extracted field angle {field_angle}° from filename")
            else:
                print(f"Could not determine field angle for {file_path}, skipping")
                continue
        
        # Find the closest field angle in photon_data
        closest_angle = min(photon_data.keys(), key=lambda x: abs(x - field_angle))
        num_photons = photon_data[closest_angle]
        
        print(f"Processing PSF for field angle {field_angle}° with {num_photons} photons")
        
        # Process the file
        result = process_psf_with_radiometry(
            file_path, num_photons, num_simulations=num_simulations,
            output_dir=output_dir, show_plots=show_plots, save_plots=save_plots,
            simulation_method=simulation_method, debug=debug
        )
        
        if result:
            results[os.path.basename(file_path)] = result
    
    return results

def extract_photon_data_from_csv(csv_file, field_angle_column=None, photon_column=None):
    """
    Extract photon counts versus field angle from a CSV file
    
    Args:
        csv_file (str): Path to the CSV file
        field_angle_column (str, optional): Name of column containing field angles
        photon_column (str, optional): Name of column containing photon counts
        
    Returns:
        dict: Dictionary mapping field angles to photon counts
    """
    try:
        # Load CSV file
        df = pd.read_csv(csv_file)
        
        # Try to automatically identify columns if not specified
        if field_angle_column is None:
            # Look for columns containing 'field', 'angle', or 'fov'
            candidates = [col for col in df.columns if 'field' in col.lower() or 
                         'angle' in col.lower() or 'fov' in col.lower()]
            if candidates:
                field_angle_column = candidates[0]
                print(f"Automatically selected field angle column: {field_angle_column}")
            else:
                print("Could not automatically identify field angle column")
                return {}
        
        if photon_column is None:
            # Look for columns containing 'photon', 'signal', or 'ph'
            candidates = [col for col in df.columns if 'photon' in col.lower() or 
                         'signal' in col.lower() or ' ph' in col.lower()]
            if candidates:
                photon_column = candidates[0]
                print(f"Automatically selected photon column: {photon_column}")
            else:
                print("Could not automatically identify photon count column")
                return {}
        
        # Extract data
        result = {}
        for _, row in df.iterrows():
            try:
                angle = float(row[field_angle_column])
                photons = int(float(row[photon_column]))
                result[angle] = photons
            except (ValueError, TypeError):
                # Skip rows with non-numeric values
                continue
        
        print(f"Extracted photon data for {len(result)} field angles")
        return result
    
    except Exception as e:
        print(f"Error extracting photon data from CSV: {str(e)}")
        return {}

def main():
    """Main function to handle command line interface"""
    parser = argparse.ArgumentParser(
        description="Process PSF files with photon Monte Carlo simulations"
    )
    
    # Input and output options
    parser.add_argument("--psf", required=True,
                      help="Path to PSF file or directory containing PSF files")
    parser.add_argument("--pattern", default="*.txt",
                      help="File pattern to match (when processing a directory)")
    parser.add_argument("--output", dest="output_dir",
                      help="Directory to save output files")
    
    # Radiometry data options
    radiometry_group = parser.add_mutually_exclusive_group(required=True)
    radiometry_group.add_argument("--csv", dest="radiometry_csv",
                               help="Path to CSV file containing radiometry data")
    radiometry_group.add_argument("--photons", type=int,
                               help="Fixed number of photons to use for all PSFs")
    
    # CSV column specification
    parser.add_argument("--angle-column",
                      help="Name of column in CSV containing field angles")
    parser.add_argument("--photon-column",
                      help="Name of column in CSV containing photon counts")
    
    # Simulation options
    parser.add_argument("--simulations", type=int, default=100,
                      help="Number of Monte Carlo simulations to run")
    parser.add_argument("--method", choices=["poisson", "monte_carlo"], default="poisson",
                      help="Simulation method: poisson or monte_carlo")
    parser.add_argument("--no-save", dest="save_plots", action="store_false",
                      help="Don't save plots")
    parser.add_argument("--show", dest="show_plots", action="store_true",
                      help="Display plots")
    parser.add_argument("--debug", action="store_true",
                      help="Print debug information")
    
    args = parser.parse_args()
    
    # Check if the PSF path exists
    if not os.path.exists(args.psf):
        print(f"Error: The path '{args.psf}' does not exist")
        sys.exit(1)
    
    # If using a CSV file, extract photon data
    if args.radiometry_csv:
        if not os.path.exists(args.radiometry_csv):
            print(f"Error: The radiometry CSV file '{args.radiometry_csv}' does not exist")
            sys.exit(1)
        
        photon_data = extract_photon_data_from_csv(
            args.radiometry_csv,
            field_angle_column=args.angle_column,
            photon_column=args.photon_column
        )
        
        if not photon_data:
            print("Error: Could not extract photon data from CSV")
            sys.exit(1)
    else:
        # Use a fixed photon count
        photon_data = {0.0: args.photons}  # Use 0.0 as a default field angle
    
    # Process PSF files
    if os.path.isfile(args.psf):
        # Single file mode
        process_psf_with_radiometry(
            args.psf,
            num_photons=list(photon_data.values())[0],  # Use first photon count
            num_simulations=args.simulations,
            output_dir=args.output_dir,
            show_plots=args.show_plots,
            save_plots=args.save_plots,
            simulation_method=args.method,
            debug=args.debug
        )
    else:
        # Directory mode
        batch_process_psfs_with_radiometry(
            args.psf,
            pattern=args.pattern,
            photon_data=photon_data,
            num_simulations=args.simulations,
            output_dir=args.output_dir,
            show_plots=args.show_plots,
            save_plots=args.save_plots,
            simulation_method=args.method,
            debug=args.debug
        )

if __name__ == "__main__":
    main()